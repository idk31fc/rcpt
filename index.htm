<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RCPT Build Editor</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 80%; margin: 0px auto; padding: 0 0px; background-color: gray}
        .textareas-container { display: flex; flex-wrap: wrap; gap: 30px; margin: 20px 0; }
        .textarea-column { flex: 1; min-width: 400px; }
        .textarea-column textarea { width: 100%; height: 120px; font-family: monospace; padding: 4px; box-sizing: border-box; border-radius: 4px; border: 1px solid #ccc; resize: vertical; background-color: lightyellow}
        .label { font-weight: bold; margin: 10px 0px 5px 0px; display: block; font-size: 1.1em; }
        .container { display: flex; flex-wrap: wrap; gap: 30px; align-items: flex-start; margin: 0px 0 0 0; }
        .column { flex: 1; min-width: 340px; }
        .custom-dropdown { position: relative; width: 100% }
        .dropbtn { background-color: lightyellow; color: black; padding: 10px 10px 10px 10px; font-size: 16px; border: 1px solid #ccc; cursor: pointer; width: 100%; text-align: left; box-sizing: border-box; border-radius: 4px; position: relative; }
        .dropbtn::after { content: "‚ñº"; position: absolute; right: 16px; top: 50%; transform: translateY(-50%); font-size: 14px; color: #555; pointer-events: none; }
        .dropbtn.open::after { content: "‚ñ≤"; }
        .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; width: 100%; box-shadow: 0px 16px 16px rgba(0,0,0,0.5); z-index: 10; max-height: 420px; overflow-y: auto; border: 1px solid #ccc; border-radius: 4px; }
        .dropdown-content div { padding: 0px; cursor: pointer; white-space: nowrap; background-color:lightyellow}
        .dropdown-content div:hover { background-color: #e0e0e0; }
        .preview-square { width: 100%; height: 40px; border: 1px solid gray; margin-bottom: 0px; border-radius: 6px; background-color: white; }
        button { padding: 12px 20px; margin: 0px 0px 0px 0; font-size: 15px; border-radius: 4px; cursor: pointer; }
        .controls { margin: 5px 0px 10px 0px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        #status { margin: 8px 0px 20px; color: #555; font-style: italic; }
        hr { border: 0; height: 3px; background-color: silver }
        input[type="text"], input[type="number"] {
            font-size: 1.5em; 
            border: 1px solid gray; 
            border-radius: 6px; 
            background-color: lightyellow; 
            padding: 4px 8px;
        }
    </style>
</head>
<body>

<p><span style="font-size:20pt"><b>RCPT Build Editor</b> ‚Äî <font color="maroon">Don't forget to make <b><i>BACKUPS!</i></b></font></span></p>
<p><font color="darkgreen">Resizing fixed (I think?). Should "WeightModifier" also scale? Ballast scaling possibly wrong. Balloon position not affected for now.</font></p>

    <div class="container">
        <div class="column">
            <div class="label">Search for color/material: (one swap at a time)</div>
            <div id="square1" class="preview-square"></div>
            <div id="dropdown1" class="custom-dropdown">
                <button class="dropbtn">Select...</button>
                <div class="dropdown-content"></div>
            </div>
        </div>

        <div class="column">
            <div class="label">Replacement color/material:</div>
            <div id="square2" class="preview-square"></div>
            <div id="dropdown2" class="custom-dropdown">
                <button class="dropbtn">Select...</button>
                <div class="dropdown-content"></div>
            </div>
        </div>
    </div>

    <div class="textareas-container">
        <div class="textarea-column">
            <div class="label">Uncolored build data:</div>
            <textarea id="input" placeholder="paste file text here to recolor...

PRO TIP: To color specific parts, make them something unique (like green) in game. Then, use this app to swap that color." spellcheck="false"></textarea>
            <div class="controls">			
                <input type="color" id="colorpicker" value="#4488ff" style="height:40px;width:40px;border:0;padding:4px;background-color:lightyellow;border-radius:6px">
                <button id="addcolor">‚Üê Add Color</button>
                <button onclick="colorOutToColorIn()" style="background-color: lightskyblue">New color swap... (copy output to input)</button>
            </div>
            <div class="controls" style="margin-top:8px;">
                <input type="text" id="customrgba" placeholder="ex: -1000,0.65,100,0.8" 
                       style="width: 12em;">
                <button id="addcustomcolor">‚Üê Add Custom RGBA</button>
            </div>
        </div>
        <div class="textarea-column">
            <div class="label">Recolored build data:</div>
            <textarea id="output" spellcheck="false"></textarea>
            <div class="controls">
                <button id="replace" style="width:30em; background-color: lightskyblue"><b>COLOR/MAT SWAP</b></button>
                <button title="copy to clipboard" onclick="navigator.clipboard.writeText(document.getElementById('output').value)" style="background-color:lightgreen;font-size:1.8em;padding:1px 10px">üóé</button>
            </div>
        </div>
    </div>

    <div id="status" style="display:none"></div>

    <div class="textareas-container">
        <div class="textarea-column">
            <div class="label">Unsized build data:</div>
            <textarea id="origdata" placeholder="paste file text here to resize..." spellcheck="false"></textarea>
            <div class="controls">
                <span style="font-size:1.5em">Scale:</span><input type="number" id="scale" value="1.000" min="0.0001" step="0.001" style="width: 5em;">
                <button onclick="resizeOutToColorIn()">Color resized build... (copy output to above input)</button><br>
                <span style="font-size:1.5em">Reposition (x,y,z,id+):</span><input type="text" id="posinput" value="0,0,0,0" style="width: 12em;">
            </div>
        </div>
        <div class="textarea-column">
            <div class="label">Resized build data:</div>
            <textarea id="newdata" spellcheck="false"></textarea>
            <div class="controls">
                <button onclick="scaler()" style="width:30em; background-color: lightskyblue"><b>APPLY SCALE + POSITION</b></button>
                <button title="copy to clipboard" onclick="navigator.clipboard.writeText(document.getElementById('newdata').value)" style="background-color:lightgreen;font-size:1.8em;padding:1px 10px">üóé</button>
            </div>
        </div>
    </div>

    <div class="container">
Note about repositioning: <br>
Units are in meters. 1.0 means 1 meter or 1000 mm (0.001 = 1 mm). While looking at the default left side view of your build, +x is away from you, -x is toward you, +y is up, -y is down, +z is to the left (or forward from the plane's perspective), -z is to the right (or backward from the plane's perspective). 
id+ is how much to add to the part ids to make them unique. 100 or more is a safe bet. I use this to make "planes in formation" by copy and pasting repositioned build parts with padded ids. 
Moving builds on the x axis will break symmetry. This tool will move symmetric (mirrored) parts correctly, but editing them later may be a pain. You might have to remove symmetry by cloning the part and deleting the unnecessary mirrored parts. 
<br> <br>
Example values:<br>
"Get this damn thing off the floor and move it backward a little (plane's POV)." x,y,z,id+ = 0,0.65,-0.02,0<br>
"It's too damn high. Lower and move it forward (plane's POV) and closer to me (don't care about symmetry)." x,y,z,id+ = -0.1,-0.5,0.007,0<br>
"I'm making a 'planes in formation.' Move this to the right, higher, backward, and add 100 to the part ids." x,y,z,id+ = 0.5,0.1,-0.5,100<br>
<img src="pos.png">
    </div>

<script>

var datain = document.getElementById("origdata")
var dataout = document.getElementById("newdata")
var mult = document.getElementById("scale")
var colorin = document.getElementById("input")
var colorout = document.getElementById("output")
var reposeInput = document.getElementById("posinput")

var searchfor = ["HalfSpan","RootChord","TipChord","Length","Elevation","SideShear","TopWidthFront","HeightFront","BottomWidthFront","TopWidthRear","HeightRear","BottomWidthRear"]
var hasScale = ["PART_MAINGEAR1","PART_TAILWHEEL","PART_NOSEWHEEL","PART_MAINGEAR2_L","PART_MAINGEAR2_R","PART_WHEEL","PART_BALLAST"]

function resizeInToColorIn(){
  if (datain.value) {colorin.value = datain.value; parseInput()}
}
function resizeOutToColorIn(){
  if (dataout.value) {colorin.value = dataout.value; parseInput()}
}
function colorOutToColorIn(){
  if (colorout.value) {colorin.value = colorout.value; parseInput()}
}

function lowestheight(str) {
  let minY = Infinity;
  let found = false;
  const blockPattern = /("LocalPosition"\s*:\s*\{)([\s\S]*?)(\})/g;
  let match;
  while ((match = blockPattern.exec(str)) !== null) {
    const inner = match[2];
    const yMatch = inner.match(/"y"\s*:\s*(-?\d*\.?\d+(?:[eE][-+]?\d+)?)/);
    if (yMatch) {
      const yVal = parseFloat(yMatch[1]);
      if (!isNaN(yVal)) {
        minY = Math.min(minY, yVal);
        found = true;
      }
    }
  }
  return found ? minY : null;
}

function heightlimiter(str, height) {
  if (height === 0 || isNaN(height)) return str;
  const blockPattern = /("LocalPosition"\s*:\s*\{)([\s\S]*?)(\})/g;
  return str.replace(blockPattern, (full, open, inner, close) => {
    let updated = inner.replace(
      /("y"\s*:\s*)(-?\d*\.?\d+(?:[eE][-+]?\d+)?)/g,
      (m, prefix, val) => {
        const num = parseFloat(val);
        if (isNaN(num)) return m;
        return `${prefix}${(num + height).toFixed(10)}`;
      }
    );
    return open + updated + close;
  });
}

function rePosition(str, reposeInput) {
  const parts = reposeInput.split(",").map(s => s.trim());
  const dx = parts[0] ? parseFloat(parts[0]) : 0;
  const dy = parts[1] ? parseFloat(parts[1]) : 0;
  const dz = parts[2] ? parseFloat(parts[2]) : 0;
  let idAdd = 0;
  if (parts[3]) {
    const parsed = parseInt(parts[3], 10);
    if (!isNaN(parsed)) idAdd = parsed;
  }
  let result = str;
  const blockPattern = /("LocalPosition"\s*:\s*\{)([\s\S]*?)(\})/g;
  result = result.replace(blockPattern, (full, open, inner, close) => {
    let updated = inner.replace(
      /"([xyz])"\s*:\s*(-?\d*\.?\d+(?:[eE][-+]?\d+)?)/g,
      (m, axis, val) => {
        let delta = 0;
        if (axis === 'x') delta = dx;
        else if (axis === 'y') delta = dy;
        else if (axis === 'z') delta = dz;
        const num = parseFloat(val);
        if (isNaN(num)) return m;
        return `"${axis}": ${(num + delta).toFixed(10)}`;
      }
    );
    return open + updated + close;
  });

  if (idAdd !== 0) {
    result = result.replace(
      /("(?:ID|Servo)"\s*:\s*)(-?\d+)/g,
      (m, prefix, val) => {
        const n = parseInt(val, 10);
        return `${prefix}${n === -1 ? -1 : n + idAdd}`;
      }
    );
  }

  return result;
}

function scaleLocalPositions(str, scaleStr) {
  if (!scaleStr || scaleStr.trim() === '' || scaleStr.trim() === '1' || scaleStr.trim() === '1.0') return str;
  const factor = parseFloat(scaleStr.trim());
  if (isNaN(factor) || factor === 1) return str;
  let result = str;
  const blockPattern = /("LocalPosition"\s*:\s*\{)([\s\S]*?)(\})/g;
  result = result.replace(blockPattern, (fullMatch, openBrace, innerContent, closeBrace) => {
    let updatedContent = innerContent.replace(
      /"([xyz])"\s*:\s*(-?\d*\.?\d+(?:[eE][-+]?\d+)?)/g,
      (match, axis, valueStr) => {
        const num = parseFloat(valueStr);
        if (isNaN(num)) return match;
        const newValue = (num * factor).toFixed(10);
        return `"${axis}": ${newValue}`;
      }
    );
    return openBrace + updatedContent + closeBrace;
  });
  return result;
}

function scaler() {
  if (isLocked(datain.value)) return;

  let scaleStr = mult.value.trim() || "1";
  let scaleFactor = parseFloat(scaleStr) || 1;

  if (scaleFactor < 0) {
    scaleFactor = Math.abs(scaleFactor);
    mult.value = scaleFactor.toFixed(3);
  }

  if (scaleFactor <= 0 || isNaN(scaleFactor)) {
    scaleFactor = 1;
    mult.value = "1.000";
  }

  let data;
  try {
    data = JSON.parse(datain.value);
  } catch (e) {
    alert("Invalid JSON input ‚Äî cannot resize.");
    return;
  }

  if (!Array.isArray(data.Parts)) {
    alert("No 'Parts' array found.");
    return;
  }

  // 1. Scale structural dimensions in FuseData and WingData
  data.Parts.forEach(part => {
    // FuseData (fuselages, bodies)
    if (part.FuseData && typeof part.FuseData === 'object') {
      Object.keys(part.FuseData).forEach(key => {
        if (searchfor.includes(key) && typeof part.FuseData[key] === 'number') {
          part.FuseData[key] *= scaleFactor;
        }
      });
    }

    // WingData (wings, stabs, fins, control surfaces)
    if (part.WingData && typeof part.WingData === 'object') {
      Object.keys(part.WingData).forEach(key => {
        if (searchfor.includes(key) && typeof part.WingData[key] === 'number') {
          part.WingData[key] *= scaleFactor;
        }
      });
    }
  });

  // 2. Handle per-part "Scale" for special SKUs
  const specialSKUs = new Set(hasScale);
  data.Parts.forEach(part => {
    if (!specialSKUs.has(part.SKU)) return;

    if ('Scale' in part) {
      // Existing ‚Üí multiply
      if (typeof part.Scale === 'number' && !isNaN(part.Scale)) {
        part.Scale *= scaleFactor;
      }
    } else {
      // Missing ‚Üí insert default (scaled from 1.0)
      part.Scale = scaleFactor;
    }
  });

  // 3. Scale all LocalPosition values
  data.Parts.forEach(part => {
    if (part.LocalPosition && typeof part.LocalPosition === 'object') {
      ['x', 'y', 'z'].forEach(axis => {
        if (typeof part.LocalPosition[axis] === 'number' && !isNaN(part.LocalPosition[axis])) {
          part.LocalPosition[axis] *= scaleFactor;
        }
      });
    }
  });

  // 4. Height adjustment: shift y so lowest point stays the same
  let origMinY = Infinity;
  data.Parts.forEach(part => {
    if (part.LocalPosition?.y != null) {
      origMinY = Math.min(origMinY, part.LocalPosition.y);
    }
  });

  if (isFinite(origMinY)) {
    let newMinY = Infinity;
    data.Parts.forEach(part => {
      if (part.LocalPosition?.y != null) {
        newMinY = Math.min(newMinY, part.LocalPosition.y);
      }
    });

    if (isFinite(newMinY)) {
      const adjust = origMinY - newMinY;
      if (Math.abs(adjust) > 1e-6) {
        data.Parts.forEach(part => {
          if (part.LocalPosition?.y != null) {
            part.LocalPosition.y += adjust;
          }
        });
      }
    }
  }

  // 5. Reposition (x,y,z) + ID/Servo offset
  const posParts = reposeInput.value.split(",").map(s => s.trim());
  const dx = parseFloat(posParts[0]) || 0;
  const dy = parseFloat(posParts[1]) || 0;
  const dz = parseFloat(posParts[2]) || 0;
  let idAdd = parseInt(posParts[3]) || 0;

  data.Parts.forEach(part => {
    if (part.LocalPosition) {
      ['x', 'y', 'z'].forEach(axis => {
        let delta = (axis === 'x' ? dx : axis === 'y' ? dy : dz);
        if (typeof part.LocalPosition[axis] === 'number') {
          part.LocalPosition[axis] += delta;
        }
      });
    }

    if (idAdd !== 0) {
      if (typeof part.ID === 'number' && part.ID !== -1) {
        part.ID += idAdd;
      }
      if (typeof part.Servo === 'number' && part.Servo !== -1) {
        part.Servo += idAdd;
      }
      if (typeof part.SymmetricPartID === 'number' && part.SymmetricPartID !== -1) {
        part.SymmetricPartID += idAdd;
      }
    }
  });

  // Output with 2-space indent (clean and readable)
  const newJson = JSON.stringify(data, null, 2);
  dataout.value = newJson;
}

function isLocked(str){
    const lockedpattern = /"[bB]"\s*:\s*1\s*,\s*"Parts"/;
    if (lockedpattern.test(str)) {
        alert('Build is LOCKED! Cannot edit.');
        return true
    }
    return false
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Color / Material logic (unchanged from original)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const materialDisplay = {
    1: { r: 0.853, g: 0.884, b: 0.813, a: 1},
    2: { r: 0.224, g: 0.235, b: 0.224, a: 1},
    3: { r: 0.651, g: 0.745, b: 0.769, a: 1},
    4: { r: 0.000, g: 0.659, b: 0.059, a: 1}
};

const materialNames = {
    1: "Material 1: Foam",
    2: "Material 2: Carbon Fiber",
    3: "Material 3: Metal",
    4: "Material 4: Camouflage"
};

const defaultColors = {
    "White":          { r: 1.000, g: 1.000, b: 1.000, a:1 },
    "Black":          { r: 0.010, g: 0.010, b: 0.010, a:1 },
    "Red":            { r: 1.000, g: 0.000, b: 0.000, a:1 },
    "Blue":           { r: 0.000, g: 0.000, b: 1.000, a:1 },
    "Yellow":         { r: 1.000, g: 0.921568632, b: 0.0156862754, a:1 },
    "Green":          { r: 0.000, g: 1.000, b: 0.000, a:1 },
    "Grey":           { r: 0.500, g: 0.500, b: 0.500, a:1 },
    "Army Green":     { r: 0.325, g: 0.365, b: 0.271, a:1 },
    "Army Brown":     { r: 0.463, g: 0.431, b: 0.376, a:1 },
    "Navy Grey":      { r: 0.583, g: 0.615, b: 0.627, a:1 },
    "Navy Blue":      { r: 0.000, g: 0.150, b: 0.360, a:1 },
    "Golden Yellow":  { r: 1.000, g: 0.761, b: 0.000, a:1 },
    "Maroon":         { r: 0.518, g: 0.110, b: 0.114, a:1 },
    "Blue Black":     { r: 0.016, g: 0.051, b: 0.200, a:1 },
    "Pearl":          { r: 0.945, g: 0.937, b: 0.937, a:1 }
};

const colorToName = new Map(Object.entries(defaultColors).map(([n,c]) => [JSON.stringify(c), n]));

let replacements = [
    ...[1,2,3,4].map(v => ({type:'material', value:v})),
    ...Object.entries(defaultColors).map(([n,v]) => ({type:'color', value:v, name:n, isDefault: true}))
];

let uniqueItems = [];
let allOccurrences = [];
let currentString = '';

const TOLERANCE = 0.001;
const MAX_DECIMALS_KEY = 10;
const DISPLAY_DECIMALS = 3;

function colorsAreClose(c1, c2) {
    return Math.abs(c1.r - c2.r) <= TOLERANCE &&
           Math.abs(c1.g - c2.g) <= TOLERANCE &&
           Math.abs(c1.b - c2.b) <= TOLERANCE &&
           Math.abs(c1.a - c2.a) <= TOLERANCE;
}

function findSimilarColorIndex(newColor) {
    for (let i = 0; i < replacements.length; i++) {
        const rep = replacements[i];
        if (rep.type === 'color' && colorsAreClose(rep.value, newColor)) {
            return i;
        }
    }
    return -1;
}

function colorKey(c) {
    return JSON.stringify({
        r: +c.r.toFixed(MAX_DECIMALS_KEY),
        g: +c.g.toFixed(MAX_DECIMALS_KEY),
        b: +c.b.toFixed(MAX_DECIMALS_KEY),
        a: +c.a.toFixed(MAX_DECIMALS_KEY)
    });
}

function getItemKey(item) {
    return item.type === 'material' ? `m${item.value}` : `c${colorKey(item.value)}`;
}

function formatDisplayValues(r, g, b) {
    return `(${r.toFixed(DISPLAY_DECIMALS)}, ${g.toFixed(DISPLAY_DECIMALS)}, ${b.toFixed(DISPLAY_DECIMALS)})`;
}

function formatCustomDisplayValues(r, g, b, a) {
    const formatOne = (num) => {
        let s = num.toFixed(10);
        s = s.replace(/0+$/, '');
        if (s.endsWith('.')) s += '0';
        return s;
    };
    return `(${formatOne(r)}, ${formatOne(g)}, ${formatOne(b)}, ${formatOne(a)})`;
}

function getDisplayName(item) {
    if (item.type === 'material') {
        return materialNames[item.value] || `Material ${item.value}`;
    }

    const key = colorKey(item.value);
    const name = colorToName.get(key);

    const { r, g, b, a = 1 } = item.value;

    const isOutOfRange = r < 0 || g < 0 || b < 0 ||
                         r > 1 || g > 1 || b > 1 ||
                         a < 1 || a > 1;

    if (item.isDefault || name) {
        const rgbStr = formatDisplayValues(r, g, b);
        return name ? `${name} ${rgbStr}` : `Custom color ${rgbStr}`;
    }
    else if (isOutOfRange || item.isCustomRGBA) {
        const rgbaStr = formatCustomDisplayValues(r, g, b, a);
        return `Custom RGBA ${rgbaStr}`;
    }
    else {
        const rgbStr = formatDisplayValues(r, g, b);
        return `Custom color ${rgbStr}`;
    }
}

function getDisplayColor(item) {
    const c = item.type === 'material' ? materialDisplay[item.value] : item.value;
    return {
        r: Math.max(0, Math.min(1, c.r ?? 0)),
        g: Math.max(0, Math.min(1, c.g ?? 0)),
        b: Math.max(0, Math.min(1, c.b ?? 0)),
        a: Math.max(0, Math.min(1, c.a ?? 1))
    };
}

function rgba(c) {
    return `rgba(${Math.round(c.r*255)},${Math.round(c.g*255)},${Math.round(c.b*255)},${c.a})`;
}

function populateDropdown1() {
    const cont = document.querySelector('#dropdown1 .dropdown-content');
    cont.innerHTML = '';
    uniqueItems.forEach((item,i) => {
        const d = document.createElement('div');
        d.dataset.idx = i;
        const name = getDisplayName(item);
        const col = getDisplayColor(item);
        d.innerHTML = `<span style="color:${rgba(col)}; font-size:1.5em; vertical-align:bottom;">‚ñ†</span> ${name}`;
        d.onclick = () => select1(i);
        cont.appendChild(d);
    });
}

function populateDropdown2() {
    const cont = document.querySelector('#dropdown2 .dropdown-content');
    cont.innerHTML = '';
    replacements.forEach((rep,i) => {
        const d = document.createElement('div');
        d.dataset.idx = i;
        const name = getDisplayName(rep);
        const col = getDisplayColor(rep);
        d.innerHTML = `<span style="color:${rgba(col)}; font-size:1.5em; vertical-align:bottom;">‚ñ†</span> ${name}`;
        d.onclick = () => select2(i);
        cont.appendChild(d);
    });
}

function updatePreviewSquare(squareId, color) {
    document.getElementById(squareId).style.backgroundColor = rgba(color);
}

function select1(idx) {
    if (idx < 0 || idx >= uniqueItems.length) return;
    const item = uniqueItems[idx];
    const btn = document.querySelector('#dropdown1 .dropbtn');
    btn.textContent = getDisplayName(item);
    btn.dataset.idx = idx;
    updatePreviewSquare('square1', getDisplayColor(item));
    document.querySelector('#dropdown1 .dropdown-content').style.display = 'none';
    btn.classList.remove('open');
}

function select2(idx) {
    if (idx < 0 || idx >= replacements.length) return;
    const rep = replacements[idx];
    const btn = document.querySelector('#dropdown2 .dropbtn');
    btn.textContent = getDisplayName(rep);
    btn.dataset.idx = idx;
    updatePreviewSquare('square2', getDisplayColor(rep));
    document.querySelector('#dropdown2 .dropdown-content').style.display = 'none';
    btn.classList.remove('open');
}

function hexToRgb(hex) {
    const r = parseInt(hex.substr(1,2),16)/255;
    const g = parseInt(hex.substr(3,2),16)/255;
    const b = parseInt(hex.substr(5,2),16)/255;
    return {r,g,b,a:1};
}

function insertDefaultColor(str) {
  const regex = /("(FuseData|WingData)"\s*:\s*\{[^}]*\})(?!\s*,\s*"(Material|Color)"\s*:)/g;
  return str.replace(regex, (match) => {
    return match + `, "Color": {"r": 1.0,"g": 1.0,"b": 1.0,"a": 1.0}`;
  });
}

function parseInput() {
    currentString = insertDefaultColor(colorin.value.trim())
    colorin.value = currentString
    const statusEl = document.getElementById('status');

    if (!currentString) {
        statusEl.textContent = '';
        uniqueItems = [];
        allOccurrences = [];
        populateDropdown1();
        document.querySelector('#dropdown1 .dropbtn').textContent = 'Select Item...';
        updatePreviewSquare('square1', {r:1,g:1,b:1,a:1});
        return;
    }

    statusEl.textContent = 'Parsing...';

    uniqueItems = [];
    allOccurrences = [];
    const seen = new Set();

    const matRe = /"Material"\s*:\s*([1-4])\b/g;
    let m;
    while ((m = matRe.exec(currentString))) {
        const val = parseInt(m[1]);
        const item = {type:'material', value:val};
        allOccurrences.push({...item, start:m.index, end:matRe.lastIndex});
        const k = getItemKey(item);
        if (!seen.has(k)) {
            seen.add(k);
            uniqueItems.push(item);
        }
    }

    const colRe = /"Color"\s*:\s*\{\s*"r"\s*:\s*([-\d.]+)\s*,\s*"g"\s*:\s*([-\d.]+)\s*,\s*"b"\s*:\s*([-\d.]+)\s*,\s*"a"\s*:\s*([-\d.]+)\s*\}/g;
    while ((m = colRe.exec(currentString))) {
        const r = parseFloat(m[1]), g = parseFloat(m[2]), b = parseFloat(m[3]), a = parseFloat(m[4]);
        const item = {type:'color', value:{r,g,b,a}};
        allOccurrences.push({...item, start:m.index, end:colRe.lastIndex});
        const k = getItemKey(item);
        if (!seen.has(k)) {
            seen.add(k);
            uniqueItems.push(item);
        }
    }

    populateDropdown1();

    if (uniqueItems.length > 0) {
        select1(0);
        statusEl.textContent = `Found ${uniqueItems.length} unique item${uniqueItems.length === 1 ? '' : 's'}`;
    } else {
        document.querySelector('#dropdown1 .dropbtn').textContent = '(no data found)';
        updatePreviewSquare('square1', {r:1,g:1,b:1,a:1});
        statusEl.textContent = 'No colors or materials found';
    }
}

let debounceTimer;
document.getElementById('input').addEventListener('input', () => {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(parseInput, 600);
});

document.getElementById('addcolor').onclick = () => {
    const hex = document.getElementById('colorpicker').value;
    const newColor = hexToRgb(hex);

    const similarIdx = findSimilarColorIndex(newColor);

    if (similarIdx !== -1) {
        select2(similarIdx);
        return;
    }

    const newIndex = replacements.length;
    replacements.push({
        type: 'color',
        value: newColor,
        isDefault: false,
        isCustomRGBA: false
    });
    populateDropdown2();
    select2(newIndex);
};

document.getElementById('addcustomcolor').onclick = () => {
    const rgbaInput = document.getElementById('customrgba').value.trim();
    
    const parts = rgbaInput.split(',').map(p => p.trim());
    if (!rgbaInput || parts.length < 3) {
        alert("Enter RGBA values (A is optional and defaults to 1)");
        return;
    }
    
    const r = parseFloat(parts[0]);
    const g = parseFloat(parts[1]);
    const b = parseFloat(parts[2]);
    const a = parts.length >= 4 ? parseFloat(parts[3]) : 1;
    
    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
        return;
    }
    
    const newColor = {r, g, b, a};

    const similarIdx = findSimilarColorIndex(newColor);
    if (similarIdx !== -1) {
        select2(similarIdx);
        document.getElementById('customrgba').value = '';
        return;
    }

    const newIndex = replacements.length;
    replacements.push({
        type: 'color',
        value: newColor,
        isDefault: false,
        isCustomRGBA: true
    });
    populateDropdown2();
    select2(newIndex);
    document.getElementById('customrgba').value = '';
};

document.getElementById('replace').onclick = () => {
    if (isLocked(input.value)) return
    const fromIdx = parseInt(document.querySelector('#dropdown1 .dropbtn').dataset.idx ?? -1);
    const toIdx   = parseInt(document.querySelector('#dropdown2 .dropbtn').dataset.idx ?? -1);

    if (fromIdx < 0 || toIdx < 0 || isNaN(fromIdx) || isNaN(toIdx)) {
        return;
    }

    const source = uniqueItems[fromIdx];
    const target = replacements[toIdx];
    const sourceKey = getItemKey(source);

    let result = currentString;
    let delta = 0;

    allOccurrences
        .filter(o => getItemKey(o) === sourceKey)
        .sort((a,b) => a.start - b.start)
        .forEach(occ => {
            let replacementText;
            if (target.type === 'material') {
                replacementText = `"Material": ${target.value}`;
            } else {
                const {r, g, b, a = 1} = target.value;
                const rStr = r.toFixed(MAX_DECIMALS_KEY).replace(/\.?0+$/, '');
                const gStr = g.toFixed(MAX_DECIMALS_KEY).replace(/\.?0+$/, '');
                const bStr = b.toFixed(MAX_DECIMALS_KEY).replace(/\.?0+$/, '');
                const aStr = a.toFixed(MAX_DECIMALS_KEY).replace(/\.?0+$/, '');
                replacementText = `"Color": {"r": ${rStr},"g": ${gStr},"b": ${bStr},"a": ${aStr}}`;
            }

            const start = occ.start + delta;
            const end   = occ.end   + delta;
            result = result.slice(0, start) + replacementText + result.slice(end);
            delta += replacementText.length - (occ.end - occ.start);
        });

    document.getElementById('output').value = result;
};

document.querySelectorAll('.dropbtn').forEach(btn => {
    btn.onclick = e => {
        e.stopPropagation();
        const content = btn.nextElementSibling;
        const isOpen = content.style.display === 'block';
        document.querySelectorAll('.dropdown-content').forEach(c => c.style.display = 'none');
        document.querySelectorAll('.dropbtn').forEach(b => b.classList.remove('open'));
        if (!isOpen) {
            content.style.display = 'block';
            btn.classList.add('open');
        }
    };
});

document.addEventListener('click', e => {
    if (!e.target.closest('.custom-dropdown')) {
        document.querySelectorAll('.dropdown-content').forEach(c => c.style.display = 'none');
        document.querySelectorAll('.dropbtn').forEach(b => b.classList.remove('open'));
    }
});

populateDropdown2();
if (replacements.length > 4) select2(4);

</script>
</body>
</html>